<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js Cylinder with Cameras</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        var scene, cameraTop, cameraFront, renderer, cylinder;
        var switchCamera = false;
        var camera
        var mobiusStripMesh
        var all_objects;
        var level_1, level_2, level_3;
        var level_1_lights, level_2_lights, level_3_lights;

        function createMobiusStrip(){
            function mobiusStrip(radius, width, height, segments) {
            var mobiusStrip = new THREE.ParametricGeometry(function(u, v, target) {
                var phi = u * Math.PI * 2 * 2; // Double the angle for two full revolutions
                var major = radius + width * v * Math.cos(phi / 2);
                var x = major * Math.cos(phi);
                var y = major * Math.sin(phi);
                var z = width * v * Math.sin(phi / 2);
                target.set(x, z, y);
            }, segments, segments);
            return mobiusStrip;
            }

            var mobiusStripGeometry = mobiusStrip(2, 0.5, 0.5, 64); // Half the size
  
            var mobiusStripMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 , side: THREE.DoubleSide });

            mobiusStripMesh = new THREE.Mesh(mobiusStripGeometry, mobiusStripMaterial);

            mobiusStripMesh.position.y = 1;
            

            return mobiusStripMesh;
        }

        function createCylinder(radius, height){
            // Cylinder
            var shape = new THREE.Shape();
            shape.moveTo(1, 0);
            shape.absarc(0, 0, radius, 0, Math.PI * 2, false);

            var extrudeSettings = {
                steps: 1,
                depth: height,
                bevelEnabled: false,
                curveSegments: 64
            };

            var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            var material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            cylinder = new THREE.Mesh(geometry, material);
            cylinder.rotation.x = Math.PI / 2; // Rotate cylinder to align along y-axis
            
            return cylinder;
        }

        function createRing(intRadius, extRadius, height, extrudeHeight) {
            var shape = new THREE.Shape();
            shape.absarc(0, 0, extRadius, 0, Math.PI * 2, false);

            var hole = new THREE.Path();
            hole.absarc(0, 0, intRadius, 0, Math.PI * 2, true);
            shape.holes.push(hole);

            var extrudeSettings = {
                steps: 1,
                depth: extrudeHeight,
                bevelEnabled: false,
                curveSegments: 64
            };

            var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.rotateX(Math.PI / 2); // Rotate to align with y-axis
            //geometry.set.y(height)
            geometry.translate(0, height, 0); // Move down to align bottom at y = 0

            var material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            var mesh = new THREE.Mesh(geometry, material);
            //scene.add(mesh);

            return mesh;
        }


        function createSpotlightsForCubes(cubePositions, level_lights) {
            cubePositions.forEach(function(pos) {
                var spotlight;

                console.log(pos)
                spotLight = new THREE.SpotLight( 0xffffff, 1 );
				spotLight.position.set( pos.x, pos.y + 0.5, pos.z);
                spotLight.target.position.set( pos.x, pos.y + 1, pos.z);
				spotLight.angle = Math.PI / 2;
				spotLight.penumbra = 1;
				spotLight.decay = 1;
				spotLight.distance = 3;

				spotLight.castShadow = true;
				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;
				spotLight.shadow.camera.near = 1;
				spotLight.shadow.camera.far = 10;
				spotLight.shadow.focus = 1;

                // Create a spotlight helper for debugging
                spotLightHelper = new THREE.SpotLightHelper(spotLight);

                // Add spotlight, its target, and helper to the scene
                level_lights.add(spotLight);
                level_lights.add(spotLight.target);
                level_lights.add(spotLightHelper);
            });
        }

        function createRingFigures(radius, height, level, level_lights) {
            var cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
            var cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });

            var angleIncrement = Math.PI / 4; // 45 degrees in radians
            var cubePositions = [];
            for (var i = 0; i < 8; i++) {
                var angle = i * angleIncrement;
                var x = radius * Math.cos(angle);
                var z = radius * Math.sin(angle);
                cubePositions.push(new THREE.Vector3(x, height + 1.5, z)); // Store cube positions as THREE.Vector3
            }

            cubePositions.forEach(function(pos) {
                var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.position.copy(pos);
                level.add(cube);
            });

            // Create spotlights for each cube
            createSpotlightsForCubes(cubePositions, level_lights);
        }


        function createCameras(){
            /* cameraTop = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            cameraTop.position.set(0, 20, 0);
            cameraTop.lookAt(0, 0, 0); */

            var aspectRatio = window.innerWidth / window.innerHeight;
            var width = 100; // Adjust as needed based on your scene size
            var height = width / aspectRatio;
            cameraTop = new THREE.OrthographicCamera(
                width / -2,   // Left
                width / 2,    // Right
                height / 2,   // Top
                height / -2,  // Bottom
                0.1,          // Near plane
                1000          // Far plane
            );
            cameraTop.position.set(0, 100, 0); // Adjust the Z position to change the "zoom" level
            cameraTop.lookAt(scene.position);

            /* cameraFront = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            cameraFront.position.set(20, -9, 20);
            cameraFront.lookAt(0, 0, 0); */
            
            var aspectRatio = window.innerWidth / window.innerHeight;
            var width = 100; // Adjust as needed based on your scene size
            var height = width / aspectRatio;
            cameraFront = new THREE.OrthographicCamera(
                width / -2,   // Left
                width / 2,    // Right
                height / 2,   // Top
                height / -2,  // Bottom
                0.1,          // Near plane
                1000          // Far plane
            );
            cameraFront.position.set(20, -9, -15); // Adjust the Z position to change the "zoom" level
            cameraFront.lookAt(0, -9 ,0);
        }

        function render(){
            renderer.render(scene, camera);
        }

        function onResize() {

            renderer.setSize(window.innerWidth, window.innerHeight);

            if (window.innerHeight > 0 && window.innerWidth > 0) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }

        }

        function onkeydown(e){

            switch(e.keyCode){

                case 49: // 1
                move_ring_1 = true;
                break;
                case 50: // 2
                move_ring_2 = true;
                break;
                case 51: // 3
                move_ring_3 = true;
                break;

                case 52: //4
                    switchCamera = !switchCamera;
                    break;
                
                case 65: //A
                case 97: //a
                    scene.traverse(function (node){
                        if(node instanceof THREE.Mesh){
                            node.material.wireframe = !node.material.wireframe;
                        }
                    });
                break;
            }
        }

        function onkeyup(e) {
            switch (e.keyCode) {
                case 49: // 1
                move_ring_1 = false;
                break;
                case 50: // 2
                move_ring_2 = false;
                break;
                case 51: // 3
                move_ring_3 = false;
                break;
            }
        }

        // Função para criar o skydome com textura
        function createSkydome(texture) {
            // Crie uma esfera grande o suficiente para envolver o carrossel
            var geometry = new THREE.SphereGeometry(90, 32, 32,0,Math.PI * 2,0,Math.PI/2);

            // Carregue a textura e aplique-a ao material
            var material = new THREE.MeshBasicMaterial({
                map: texture, // Aplique a textura carregada
                side: THREE.BackSide // Certifique-se de que a textura seja visível por dentro da esfera
            });

            // Crie a malha da esfera com o material
            var skydome = new THREE.Mesh(geometry, material);

            skydome.position.set(0,-20,0)

            // Adicione o skydome à cena
            scene.add(skydome);
        }

        // Função para carregar a textura e criar o skydome
        function loadTextureAndCreateSkydome() {
            var textureLoader = new THREE.TextureLoader();
            // Carregue a textura da imagem
            textureLoader.load(
                'oskar_sky.png', // Substitua pelo caminho correto para a sua imagem
                function(texture) {
                    // Chame a função para criar o skydome e passe a textura carregada como argumento
                    createSkydome(texture);
                },
                // Função de progresso (opcional)
                function(xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% carregado');
                },
                // Função de erro (opcional)
                function(error) {
                    console.log('Erro ao carregar a textura', error);
                }
            );
        }

        // No seu código, chame a função para carregar a textura e criar o skydome



        function createScene(){
            scene = new THREE.Scene();

            loadTextureAndCreateSkydome();

            var ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            var directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(10, 10, 10).normalize();
            scene.add(directionalLight);




            var ring_1, ring_2, ring_3;
            all_objects = new THREE.Group();
            level_1 = new THREE.Group();
            level_2 = new THREE.Group();
            level_3 = new THREE.Group();
            level_1_lights = new THREE.Group();
            level_2_lights = new THREE.Group();
            level_3_lights = new THREE.Group();

            cylinder = createCylinder(4.5, 18);
            
            ring_1 = createRing(4.5, 7.5, -2 , 1);
            level_1.add(ring_1)
            createRingFigures(6, -2, level_1, level_1_lights);
            level_1.position.set(0,2,0)
            //level_1.add(level_1_lights);
            //scene.add(level_1);

            ring_2 = createRing(7.5, 10.5, -2 , 1);
            level_2.add(ring_2)
            createRingFigures(9, -2, level_2, level_2_lights);
            level_2.position.set(0,2,0)
            //level_2.add(level_2_lights);
            //scene.add(level_2);

            ring_3 = createRing(10.5, 13.5, -2 , 1);
            level_3.add(ring_3)
            createRingFigures(12, -2, level_3, level_3_lights);
            level_3.position.set(0,2,0)
            //level_3.add(level_3_lights);
            //scene.add(level_3);


            mobiusStrip = createMobiusStrip();


            all_objects.add(cylinder, mobiusStrip, level_1, level_2 , level_3);
            scene.add(all_objects);

            scene.add(level_1_lights, level_2_lights, level_3_lights)

            scene.add(new THREE.AxesHelper(10));
        }

        function onResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            var aspectRatio = window.innerWidth / window.innerHeight;

            // Update aspect ratio for all cameras
            cameraFront.left = -10 * aspectRatio;
            cameraFront.right = 10 * aspectRatio;
            cameraFront.top = 10;
            cameraFront.bottom = -10;
            cameraFront.updateProjectionMatrix();

            cameraTop.left = -10 * aspectRatio;
            cameraTop.right = 10 * aspectRatio;
            cameraTop.top = 10;
            cameraTop.bottom = -10;
            cameraTop.updateProjectionMatrix();

            render();
        }

        function init() {
            // Renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            //Scene
            createScene();
            // Cameras
            createCameras();
            
            
            window.addEventListener("resize", onResize);
            window.addEventListener("keydown", onkeydown);
            window.addEventListener("keyup", onkeyup);

           
        }

        function animateCubes(cubes) {
            cubes.slice(1, 9).forEach(function(cube) {
                //cube.rotation.x += 0.01; // Rotate around the X axis
                cube.rotation.z += 0.01; // Rotate around the Z axis
                //cube.rotation.y += 0.01; // Rotate around the Y axis
            });
        }

        var level1Jumping = true, level2Jumping = true, level3Jumping = true;


        var level1JumpSpeed = 0.1, level2JumpSpeed = 0.1, level3JumpSpeed = 0.1; // Adjust as needed

        let previousTime = performance.now(); // Variable to store the previous timestamp

        function moveSpotLights(level_lights, level, spotlightMoveSpeed){
            k=1;
            for(i = 0; i < 24;i+=3){
                level_lights.children[i].position.copy(level.children[k].getWorldPosition(new THREE.Vector3()));
                level_lights.children[i].position.y -= 1.5;
                level_lights.children[i].target.position.copy(level.children[k].getWorldPosition(new THREE.Vector3()));
                level_lights.children[i+2].position.copy(level.children[k].getWorldPosition(new THREE.Vector3()));
                k++;
            }

        }

        function updadteSpotlightHelper(){

            for(i = 2; i<=23; i+=3){
                level_1_lights.children[i].update()
                level_2_lights.children[i].update()
                level_3_lights.children[i].update()
            }
        }

        var move_ring_1 = false, move_ring_2 =false, move_ring_3 = false;


        function animate() {

            const currentTime = performance.now(); // Get the current timestamp
            const deltaTime = (currentTime - previousTime) / 100; // Calculate the time difference since the last frame, in seconds
            previousTime = currentTime; // Update previous time

            updadteSpotlightHelper();

            
            if (switchCamera) {
                camera = cameraFront;
            } else {
                camera = cameraTop;
            }


            if (move_ring_1 ==true){            
                if (level_1.position.y >= 2) {
                    level1Jumping = false;
                } else if (level_1.position.y <= -15) {
                    level1Jumping = true;
                }

                // Update position based on animation state
                var spotlightMoveSpeed = 0.1;

                // Update position based on animation state
                if (level1Jumping) {
                    moveSpotLights(level_1_lights, level_1, spotlightMoveSpeed * deltaTime)
                    level_1.position.y += spotlightMoveSpeed * deltaTime;
                } else {
                    moveSpotLights(level_1_lights, level_1, -spotlightMoveSpeed * deltaTime) //negative speed means reverse moviment
                    level_1.position.y -= spotlightMoveSpeed * deltaTime;
                }
            }


            if (move_ring_2 ==true){
                if (level_2.position.y >= 2) {
                    level2Jumping = false;
                } else if (level_2.position.y <= -15) {
                    level2Jumping = true;
                }

                // Update position based on animation state
                if (level2Jumping) {
                    moveSpotLights(level_2_lights, level_2, spotlightMoveSpeed * deltaTime)
                    level_2.position.y += level2JumpSpeed * deltaTime;
                } else {
                    moveSpotLights(level_2_lights, level_2, -spotlightMoveSpeed * deltaTime)
                    level_2.position.y -= level2JumpSpeed * deltaTime;
                }
            }

            if (move_ring_3 ==true){
                if (level_3.position.y >= 2) {
                    level3Jumping = false;
                } else if (level_3.position.y <= -15) {
                    level3Jumping = true;
                }

                // Update position based on animation state
                if (level3Jumping) {
                    moveSpotLights(level_3_lights, level_3, spotlightMoveSpeed * deltaTime)
                    level_3.position.y += level3JumpSpeed * deltaTime;
                } else {
                    moveSpotLights(level_3_lights, level_3, -spotlightMoveSpeed * deltaTime)
                    level_3.position.y -= level3JumpSpeed * deltaTime;
                }
            }

            all_objects.rotation.y += 0.01

            animateCubes(level_1.children);
            animateCubes(level_2.children);
            animateCubes(level_3.children);

            if (move_ring_1 == false ){
                moveSpotLights(level_1_lights, level_1, 0 * deltaTime)
            }if (move_ring_2 == false ){
                moveSpotLights(level_2_lights, level_2, 0 * deltaTime)
            }if (move_ring_3 == false){
                moveSpotLights(level_3_lights, level_3, 0 * deltaTime)
            }
            

            render()
            requestAnimationFrame(animate);
        }

        init();
        animate();

    </script>
</body>
</html>
